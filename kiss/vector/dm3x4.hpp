// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#pragma once

#include "kissmath.hpp"

#include "dv3.hpp"
#include "dv4.hpp"

namespace vector {
	
	//// matrix forward declarations
	struct dm2;
	struct dm3;
	struct dm4;
	struct dm2x3;
	struct fm3x4;
	
	struct dm3x4 {
		dv3 arr[4]; // column major for compatibility with OpenGL
		
		//// Accessors
		
		
		// get cell with r,c indecies (r=row, c=column)
		inline FORCEINLINE f64 const& get (int r, int c) const {
			return arr[c][r];
		}
		
		// get matrix column
		inline FORCEINLINE dv3 const& get_column (int indx) const {
			return arr[indx];
		}
		// get matrix row
		dv4 get_row (int indx) const;
		
		//// Constructors
		
		
		inline FORCEINLINE dm3x4 () {
			
		}
		
		// supply one value for all cells
		inline FORCEINLINE explicit dm3x4 (f64 all): 
		arr{dv3(all, all, all),
			dv3(all, all, all),
			dv3(all, all, all),
			dv3(all, all, all)} {
			
		}
		
		// supply all cells, in row major order for readability -> c<r><c> (r=row, c=column)
		inline FORCEINLINE explicit dm3x4 (f64 c00, f64 c01, f64 c02, f64 c03,
										   f64 c10, f64 c11, f64 c12, f64 c13,
										   f64 c20, f64 c21, f64 c22, f64 c23): 
		arr{dv3(c00, c10, c20),
			dv3(c01, c11, c21),
			dv3(c02, c12, c22),
			dv3(c03, c13, c23)} {
			
		}
		
		// static rows() and columns() methods are preferred over constructors, to avoid confusion if column or row vectors are supplied to the constructor
		// supply all row vectors
		static dm3x4 rows (dv4 row0, dv4 row1, dv4 row2);
		// supply all cells in row major order
		static dm3x4 rows (f64 c00, f64 c01, f64 c02, f64 c03,
						   f64 c10, f64 c11, f64 c12, f64 c13,
						   f64 c20, f64 c21, f64 c22, f64 c23);
		// supply all column vectors
		static dm3x4 columns (dv3 col0, dv3 col1, dv3 col2, dv3 col3);
		// supply all cells in column major order
		static dm3x4 columns (f64 c00, f64 c10, f64 c20,
							  f64 c01, f64 c11, f64 c21,
							  f64 c02, f64 c12, f64 c22,
							  f64 c03, f64 c13, f64 c23);
		
		
		// identity matrix
		static inline FORCEINLINE dm3x4 identity () {
			return dm3x4(1,0,0,0,
						 0,1,0,0,
						 0,0,1,0);
		}
		
		// Casting operators
		
		// extend/truncate matrix of other size
		explicit operator dm2 () const;
		// extend/truncate matrix of other size
		explicit operator dm3 () const;
		// extend/truncate matrix of other size
		explicit operator dm4 () const;
		// extend/truncate matrix of other size
		explicit operator dm2x3 () const;
		// typecast
		explicit operator fm3x4 () const;
		
		// Elementwise operators
		
		dm3x4& operator+= (f64 r);
		dm3x4& operator-= (f64 r);
		dm3x4& operator*= (f64 r);
		dm3x4& operator/= (f64 r);
		
		// Matrix multiplication
		
		dm3x4& operator*= (dm3x4 const& r);
	};
	
	// Elementwise operators
	
	dm3x4 operator+ (dm3x4 const& m);
	dm3x4 operator- (dm3x4 const& m);
	
	dm3x4 operator+ (dm3x4 const& l, dm3x4 const& r);
	dm3x4 operator+ (dm3x4 const& l, f64 r);
	dm3x4 operator+ (f64 l, dm3x4 const& r);
	
	dm3x4 operator- (dm3x4 const& l, dm3x4 const& r);
	dm3x4 operator- (dm3x4 const& l, f64 r);
	dm3x4 operator- (f64 l, dm3x4 const& r);
	
	dm3x4 mul_elementwise (dm3x4 const& l, dm3x4 const& r);
	dm3x4 operator* (dm3x4 const& l, f64 r);
	dm3x4 operator* (f64 l, dm3x4 const& r);
	
	dm3x4 div_elementwise (dm3x4 const& l, dm3x4 const& r);
	dm3x4 operator/ (dm3x4 const& l, f64 r);
	dm3x4 operator/ (f64 l, dm3x4 const& r);
	
	// Matrix ops
	
	dm3x4 operator* (dm3x4 const& l, dm4 const& r);
	dv3 operator* (dm3x4 const& l, dv4 r);
	dv4 operator* (dv3 l, dm3x4 const& r);
	
	// Matrix op shortforms for working with 3x4 matricies as 3x3 matricies plus translation
	
	// dm3x4 * dm3 = dm3x4, shortform for dm3x4 * (dm4)dm3 = dm3x4
	dm3x4 operator* (dm3x4 const& l, dm3 const& r);
	// dm3x4 * dm3x4 = dm3x4, shortform for dm3x4 * (dm4)dm3x4 = dm3x4
	dm3x4 operator* (dm3x4 const& l, dm3x4 const& r);
	// dm3x4 * dv3 = dv3, shortform for dm3x4 * dv4(dv3, 1) = dv3
	dv3 operator* (dm3x4 const& l, dv3 r);
} // namespace vector

