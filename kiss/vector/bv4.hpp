// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#pragma once

#include "kissmath.hpp"


namespace vector {
	//// forward declarations
	struct bv2;
	struct bv3;
	struct bv4;
	struct fv4;
	struct dv4;
	struct iv4;
	struct s64v4;
	struct u8v4;
	
	struct bv4 {
		union {
			struct {
				bool	x, y, z, w;
			};
			bool		arr[4];
		};
		
		inline FORCEINLINE bool& operator[] (int i) {
			return arr[i];
		}
		
		inline FORCEINLINE bool const& operator[] (int i) const {
			return arr[i];
		}
		
		
		inline FORCEINLINE bv4 () {
			
		}
		
		// sets all components to one value
		// implicit constructor -> v3(x,y,z) * 5 will be turned into v3(x,y,z) * v3(5) by to compiler to be able to execute operator*(v3, v3), which is desirable, also v3 a = 0; works
		inline FORCEINLINE bv4 (bool all): x{all}, y{all}, z{all}, w{all} {
			
		}
		
		// supply all components
		inline FORCEINLINE bv4 (bool x, bool y, bool z, bool w): x{x}, y{y}, z{z}, w{w} {
			
		}
		// extend vector
		bv4 (bv2 xy, bool z, bool w);
		// extend vector
		bv4 (bv3 xyz, bool w);
		
		//// Truncating cast operators
		
		explicit operator bv2 () const;
		explicit operator bv3 () const;
		
		//// Type cast operators
		
	};
	
	//// reducing ops
	// all components are true
	bool all (bv4 v);
	// any components is true
	bool any (bv4 v);
	
	//// arthmethic ops
	
	inline FORCEINLINE bv4 operator! (bv4 v) {
		return bv4(!v.x, !v.y, !v.z, !v.w);
	}
	
	inline FORCEINLINE bv4 operator&& (bv4 l, bv4 r) {
		return bv4(l.x && r.x, l.y && r.y, l.z && r.z, l.w && r.w);
	}
	
	inline FORCEINLINE bv4 operator|| (bv4 l, bv4 r) {
		return bv4(l.x || r.x, l.y || r.y, l.z || r.z, l.w || r.w);
	}
	
	//// comparison ops
	bv4 operator== (bv4 l, bv4 r);
	bv4 operator!= (bv4 l, bv4 r);
	// vectors are equal, equivalent to all(l == r)
	bool equal (bv4 l, bv4 r);
	// componentwise ternary c ? l : r
	bv4 select (bv4 c, bv4 l, bv4 r);
}// namespace vector

