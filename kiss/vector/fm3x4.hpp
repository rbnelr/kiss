// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#pragma once

#include "kissmath.hpp"

#include "fv3.hpp"
#include "fv4.hpp"

namespace vector {
	
	//// matrix forward declarations
	struct fm2;
	struct fm3;
	struct fm4;
	struct fm2x3;
	struct dm3x4;
	
	struct fm3x4 {
		fv3 arr[4]; // column major for compatibility with OpenGL
		
		//// Accessors
		
		
		// get cell with r,c indecies (r=row, c=column)
		inline FORCEINLINE f32 const& get (int r, int c) const {
			return arr[c][r];
		}
		
		// get matrix column
		inline FORCEINLINE fv3 const& get_column (int indx) const {
			return arr[indx];
		}
		// get matrix row
		fv4 get_row (int indx) const;
		
		//// Constructors
		
		
		inline FORCEINLINE fm3x4 () {
			
		}
		
		// supply one value for all cells
		inline FORCEINLINE explicit fm3x4 (f32 all): 
		arr{fv3(all, all, all),
			fv3(all, all, all),
			fv3(all, all, all),
			fv3(all, all, all)} {
			
		}
		
		// supply all cells, in row major order for readability -> c<r><c> (r=row, c=column)
		inline FORCEINLINE explicit fm3x4 (f32 c00, f32 c01, f32 c02, f32 c03,
										   f32 c10, f32 c11, f32 c12, f32 c13,
										   f32 c20, f32 c21, f32 c22, f32 c23): 
		arr{fv3(c00, c10, c20),
			fv3(c01, c11, c21),
			fv3(c02, c12, c22),
			fv3(c03, c13, c23)} {
			
		}
		
		// static rows() and columns() methods are preferred over constructors, to avoid confusion if column or row vectors are supplied to the constructor
		// supply all row vectors
		static fm3x4 rows (fv4 row0, fv4 row1, fv4 row2);
		// supply all cells in row major order
		static fm3x4 rows (f32 c00, f32 c01, f32 c02, f32 c03,
						   f32 c10, f32 c11, f32 c12, f32 c13,
						   f32 c20, f32 c21, f32 c22, f32 c23);
		// supply all column vectors
		static fm3x4 columns (fv3 col0, fv3 col1, fv3 col2, fv3 col3);
		// supply all cells in column major order
		static fm3x4 columns (f32 c00, f32 c10, f32 c20,
							  f32 c01, f32 c11, f32 c21,
							  f32 c02, f32 c12, f32 c22,
							  f32 c03, f32 c13, f32 c23);
		
		
		// identity matrix
		static inline FORCEINLINE fm3x4 identity () {
			return fm3x4(1,0,0,0,
						 0,1,0,0,
						 0,0,1,0);
		}
		
		// Casting operators
		
		// extend/truncate matrix of other size
		explicit operator fm2 () const;
		// extend/truncate matrix of other size
		explicit operator fm3 () const;
		// extend/truncate matrix of other size
		explicit operator fm4 () const;
		// extend/truncate matrix of other size
		explicit operator fm2x3 () const;
		// typecast
		explicit operator dm3x4 () const;
		
		// Elementwise operators
		
		fm3x4& operator+= (f32 r);
		fm3x4& operator-= (f32 r);
		fm3x4& operator*= (f32 r);
		fm3x4& operator/= (f32 r);
		
		// Matrix multiplication
		
		fm3x4& operator*= (fm3x4 const& r);
	};
	
	// Elementwise operators
	
	fm3x4 operator+ (fm3x4 const& m);
	fm3x4 operator- (fm3x4 const& m);
	
	fm3x4 operator+ (fm3x4 const& l, fm3x4 const& r);
	fm3x4 operator+ (fm3x4 const& l, f32 r);
	fm3x4 operator+ (f32 l, fm3x4 const& r);
	
	fm3x4 operator- (fm3x4 const& l, fm3x4 const& r);
	fm3x4 operator- (fm3x4 const& l, f32 r);
	fm3x4 operator- (f32 l, fm3x4 const& r);
	
	fm3x4 mul_elementwise (fm3x4 const& l, fm3x4 const& r);
	fm3x4 operator* (fm3x4 const& l, f32 r);
	fm3x4 operator* (f32 l, fm3x4 const& r);
	
	fm3x4 div_elementwise (fm3x4 const& l, fm3x4 const& r);
	fm3x4 operator/ (fm3x4 const& l, f32 r);
	fm3x4 operator/ (f32 l, fm3x4 const& r);
	
	// Matrix ops
	
	fm3x4 operator* (fm3x4 const& l, fm4 const& r);
	fv3 operator* (fm3x4 const& l, fv4 r);
	fv4 operator* (fv3 l, fm3x4 const& r);
	
	// Matrix op shortforms for working with 3x4 matricies as 3x3 matricies plus translation
	
	// fm3x4 * fm3 = fm3x4, shortform for fm3x4 * (fm4)fm3 = fm3x4
	fm3x4 operator* (fm3x4 const& l, fm3 const& r);
	// fm3x4 * fm3x4 = fm3x4, shortform for fm3x4 * (fm4)fm3x4 = fm3x4
	fm3x4 operator* (fm3x4 const& l, fm3x4 const& r);
	// fm3x4 * fv3 = fv3, shortform for fm3x4 * fv4(fv3, 1) = fv3
	fv3 operator* (fm3x4 const& l, fv3 r);
} // namespace vector

