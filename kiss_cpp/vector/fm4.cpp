// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#include "fm4.hpp"

#include "fm2.hpp"
#include "fm3.hpp"
#include "fm2x3.hpp"
#include "fm3x4.hpp"
#include "dm4.hpp"

namespace vector {
	
	//// Accessors
	
	
	// get matrix row
	fv4 fm4::get_row (int indx) const {
		return fv4(arr[0][indx], arr[1][indx], arr[2][indx], arr[3][indx]);
	}
	
	//// Constructors
	
	
	// static rows() and columns() methods are preferred over constructors, to avoid confusion if column or row vectors are supplied to the constructor
	
	// supply all row vectors
	fm4 fm4::rows (fv4 row0, fv4 row1, fv4 row2, fv4 row3) {
		return fm4(row0[0], row0[1], row0[2], row0[3],
				   row1[0], row1[1], row1[2], row1[3],
				   row2[0], row2[1], row2[2], row2[3],
				   row3[0], row3[1], row3[2], row3[3]);
	}
	
	// supply all cells in row major order
	fm4 fm4::rows (f32 c00, f32 c01, f32 c02, f32 c03,
				   f32 c10, f32 c11, f32 c12, f32 c13,
				   f32 c20, f32 c21, f32 c22, f32 c23,
				   f32 c30, f32 c31, f32 c32, f32 c33) {
		return fm4(c00, c01, c02, c03,
				   c10, c11, c12, c13,
				   c20, c21, c22, c23,
				   c30, c31, c32, c33);
	}
	
	// supply all column vectors
	fm4 fm4::columns (fv4 col0, fv4 col1, fv4 col2, fv4 col3) {
		return fm4(col0[0], col1[0], col2[0], col3[0],
				   col0[1], col1[1], col2[1], col3[1],
				   col0[2], col1[2], col2[2], col3[2],
				   col0[3], col1[3], col2[3], col3[3]);
	}
	
	// supply all cells in column major order
	fm4 fm4::columns (f32 c00, f32 c10, f32 c20, f32 c30,
					  f32 c01, f32 c11, f32 c21, f32 c31,
					  f32 c02, f32 c12, f32 c22, f32 c32,
					  f32 c03, f32 c13, f32 c23, f32 c33) {
		return fm4(c00, c01, c02, c03,
				   c10, c11, c12, c13,
				   c20, c21, c22, c23,
				   c30, c31, c32, c33);
	}
	
	
	// Casting operators
	
	
	// extend/truncate matrix of other size
	fm4::operator fm2 () const {
		return fm2(arr[0][0], arr[1][0],
				   arr[0][1], arr[1][1]);
	}
	
	// extend/truncate matrix of other size
	fm4::operator fm3 () const {
		return fm3(arr[0][0], arr[1][0], arr[2][0],
				   arr[0][1], arr[1][1], arr[2][1],
				   arr[0][2], arr[1][2], arr[2][2]);
	}
	
	// extend/truncate matrix of other size
	fm4::operator fm2x3 () const {
		return fm2x3(arr[0][0], arr[1][0], arr[2][0],
					 arr[0][1], arr[1][1], arr[2][1]);
	}
	
	// extend/truncate matrix of other size
	fm4::operator fm3x4 () const {
		return fm3x4(arr[0][0], arr[1][0], arr[2][0], arr[3][0],
					 arr[0][1], arr[1][1], arr[2][1], arr[3][1],
					 arr[0][2], arr[1][2], arr[2][2], arr[3][2]);
	}
	
	// typecast
	fm4::operator dm4 () const {
		return dm4((f64)arr[0][0], (f64)arr[0][1], (f64)arr[0][2], (f64)arr[0][3],
				   (f64)arr[1][0], (f64)arr[1][1], (f64)arr[1][2], (f64)arr[1][3],
				   (f64)arr[2][0], (f64)arr[2][1], (f64)arr[2][2], (f64)arr[2][3],
				   (f64)arr[3][0], (f64)arr[3][1], (f64)arr[3][2], (f64)arr[3][3]);
	}
	
	// Elementwise operators
	
	
	fm4& fm4::operator+= (f32 r) {
		*this = *this + r;
		return *this;
	}
	
	fm4& fm4::operator-= (f32 r) {
		*this = *this - r;
		return *this;
	}
	
	fm4& fm4::operator*= (f32 r) {
		*this = *this * r;
		return *this;
	}
	
	fm4& fm4::operator/= (f32 r) {
		*this = *this / r;
		return *this;
	}
	
	// Matrix multiplication
	
	
	fm4& fm4::operator*= (fm4 const& r) {
		*this = *this * r;
		return *this;
	}
	
	// Elementwise operators
	
	
	fm4 operator+ (fm4 const& m) {
		return fm4(+m.arr[0][0], +m.arr[1][0], +m.arr[2][0], +m.arr[3][0],
				   +m.arr[0][1], +m.arr[1][1], +m.arr[2][1], +m.arr[3][1],
				   +m.arr[0][2], +m.arr[1][2], +m.arr[2][2], +m.arr[3][2],
				   +m.arr[0][3], +m.arr[1][3], +m.arr[2][3], +m.arr[3][3]);
	}
	
	fm4 operator- (fm4 const& m) {
		return fm4(-m.arr[0][0], -m.arr[1][0], -m.arr[2][0], -m.arr[3][0],
				   -m.arr[0][1], -m.arr[1][1], -m.arr[2][1], -m.arr[3][1],
				   -m.arr[0][2], -m.arr[1][2], -m.arr[2][2], -m.arr[3][2],
				   -m.arr[0][3], -m.arr[1][3], -m.arr[2][3], -m.arr[3][3]);
	}
	
	
	fm4 operator+ (fm4 const& l, fm4 const& r) {
		return fm4(l.arr[0][0] + r.arr[0][0], l.arr[1][0] + r.arr[1][0], l.arr[2][0] + r.arr[2][0], l.arr[3][0] + r.arr[3][0],
				   l.arr[0][1] + r.arr[0][1], l.arr[1][1] + r.arr[1][1], l.arr[2][1] + r.arr[2][1], l.arr[3][1] + r.arr[3][1],
				   l.arr[0][2] + r.arr[0][2], l.arr[1][2] + r.arr[1][2], l.arr[2][2] + r.arr[2][2], l.arr[3][2] + r.arr[3][2],
				   l.arr[0][3] + r.arr[0][3], l.arr[1][3] + r.arr[1][3], l.arr[2][3] + r.arr[2][3], l.arr[3][3] + r.arr[3][3]);
	}
	
	fm4 operator+ (fm4 const& l, f32 r) {
		return fm4(l.arr[0][0] + r, l.arr[1][0] + r, l.arr[2][0] + r, l.arr[3][0] + r,
				   l.arr[0][1] + r, l.arr[1][1] + r, l.arr[2][1] + r, l.arr[3][1] + r,
				   l.arr[0][2] + r, l.arr[1][2] + r, l.arr[2][2] + r, l.arr[3][2] + r,
				   l.arr[0][3] + r, l.arr[1][3] + r, l.arr[2][3] + r, l.arr[3][3] + r);
	}
	
	fm4 operator+ (f32 l, fm4 const& r) {
		return fm4(l + r.arr[0][0], l + r.arr[1][0], l + r.arr[2][0], l + r.arr[3][0],
				   l + r.arr[0][1], l + r.arr[1][1], l + r.arr[2][1], l + r.arr[3][1],
				   l + r.arr[0][2], l + r.arr[1][2], l + r.arr[2][2], l + r.arr[3][2],
				   l + r.arr[0][3], l + r.arr[1][3], l + r.arr[2][3], l + r.arr[3][3]);
	}
	
	
	fm4 operator- (fm4 const& l, fm4 const& r) {
		return fm4(l.arr[0][0] - r.arr[0][0], l.arr[1][0] - r.arr[1][0], l.arr[2][0] - r.arr[2][0], l.arr[3][0] - r.arr[3][0],
				   l.arr[0][1] - r.arr[0][1], l.arr[1][1] - r.arr[1][1], l.arr[2][1] - r.arr[2][1], l.arr[3][1] - r.arr[3][1],
				   l.arr[0][2] - r.arr[0][2], l.arr[1][2] - r.arr[1][2], l.arr[2][2] - r.arr[2][2], l.arr[3][2] - r.arr[3][2],
				   l.arr[0][3] - r.arr[0][3], l.arr[1][3] - r.arr[1][3], l.arr[2][3] - r.arr[2][3], l.arr[3][3] - r.arr[3][3]);
	}
	
	fm4 operator- (fm4 const& l, f32 r) {
		return fm4(l.arr[0][0] - r, l.arr[1][0] - r, l.arr[2][0] - r, l.arr[3][0] - r,
				   l.arr[0][1] - r, l.arr[1][1] - r, l.arr[2][1] - r, l.arr[3][1] - r,
				   l.arr[0][2] - r, l.arr[1][2] - r, l.arr[2][2] - r, l.arr[3][2] - r,
				   l.arr[0][3] - r, l.arr[1][3] - r, l.arr[2][3] - r, l.arr[3][3] - r);
	}
	
	fm4 operator- (f32 l, fm4 const& r) {
		return fm4(l - r.arr[0][0], l - r.arr[1][0], l - r.arr[2][0], l - r.arr[3][0],
				   l - r.arr[0][1], l - r.arr[1][1], l - r.arr[2][1], l - r.arr[3][1],
				   l - r.arr[0][2], l - r.arr[1][2], l - r.arr[2][2], l - r.arr[3][2],
				   l - r.arr[0][3], l - r.arr[1][3], l - r.arr[2][3], l - r.arr[3][3]);
	}
	
	
	fm4 mul_elementwise (fm4 const& l, fm4 const& r) {
		return fm4(l.arr[0][0] * r.arr[0][0], l.arr[1][0] * r.arr[1][0], l.arr[2][0] * r.arr[2][0], l.arr[3][0] * r.arr[3][0],
				   l.arr[0][1] * r.arr[0][1], l.arr[1][1] * r.arr[1][1], l.arr[2][1] * r.arr[2][1], l.arr[3][1] * r.arr[3][1],
				   l.arr[0][2] * r.arr[0][2], l.arr[1][2] * r.arr[1][2], l.arr[2][2] * r.arr[2][2], l.arr[3][2] * r.arr[3][2],
				   l.arr[0][3] * r.arr[0][3], l.arr[1][3] * r.arr[1][3], l.arr[2][3] * r.arr[2][3], l.arr[3][3] * r.arr[3][3]);
	}
	
	fm4 operator* (fm4 const& l, f32 r) {
		return fm4(l.arr[0][0] * r, l.arr[1][0] * r, l.arr[2][0] * r, l.arr[3][0] * r,
				   l.arr[0][1] * r, l.arr[1][1] * r, l.arr[2][1] * r, l.arr[3][1] * r,
				   l.arr[0][2] * r, l.arr[1][2] * r, l.arr[2][2] * r, l.arr[3][2] * r,
				   l.arr[0][3] * r, l.arr[1][3] * r, l.arr[2][3] * r, l.arr[3][3] * r);
	}
	
	fm4 operator* (f32 l, fm4 const& r) {
		return fm4(l * r.arr[0][0], l * r.arr[1][0], l * r.arr[2][0], l * r.arr[3][0],
				   l * r.arr[0][1], l * r.arr[1][1], l * r.arr[2][1], l * r.arr[3][1],
				   l * r.arr[0][2], l * r.arr[1][2], l * r.arr[2][2], l * r.arr[3][2],
				   l * r.arr[0][3], l * r.arr[1][3], l * r.arr[2][3], l * r.arr[3][3]);
	}
	
	
	fm4 div_elementwise (fm4 const& l, fm4 const& r) {
		return fm4(l.arr[0][0] / r.arr[0][0], l.arr[1][0] / r.arr[1][0], l.arr[2][0] / r.arr[2][0], l.arr[3][0] / r.arr[3][0],
				   l.arr[0][1] / r.arr[0][1], l.arr[1][1] / r.arr[1][1], l.arr[2][1] / r.arr[2][1], l.arr[3][1] / r.arr[3][1],
				   l.arr[0][2] / r.arr[0][2], l.arr[1][2] / r.arr[1][2], l.arr[2][2] / r.arr[2][2], l.arr[3][2] / r.arr[3][2],
				   l.arr[0][3] / r.arr[0][3], l.arr[1][3] / r.arr[1][3], l.arr[2][3] / r.arr[2][3], l.arr[3][3] / r.arr[3][3]);
	}
	
	fm4 operator/ (fm4 const& l, f32 r) {
		return fm4(l.arr[0][0] / r, l.arr[1][0] / r, l.arr[2][0] / r, l.arr[3][0] / r,
				   l.arr[0][1] / r, l.arr[1][1] / r, l.arr[2][1] / r, l.arr[3][1] / r,
				   l.arr[0][2] / r, l.arr[1][2] / r, l.arr[2][2] / r, l.arr[3][2] / r,
				   l.arr[0][3] / r, l.arr[1][3] / r, l.arr[2][3] / r, l.arr[3][3] / r);
	}
	
	fm4 operator/ (f32 l, fm4 const& r) {
		return fm4(l / r.arr[0][0], l / r.arr[1][0], l / r.arr[2][0], l / r.arr[3][0],
				   l / r.arr[0][1], l / r.arr[1][1], l / r.arr[2][1], l / r.arr[3][1],
				   l / r.arr[0][2], l / r.arr[1][2], l / r.arr[2][2], l / r.arr[3][2],
				   l / r.arr[0][3], l / r.arr[1][3], l / r.arr[2][3], l / r.arr[3][3]);
	}
	
	// Matrix ops
	
	
	fm4 operator* (fm4 const& l, fm4 const& r) {
		fm4 ret;
		ret.arr[0] = l * r.arr[0];
		ret.arr[1] = l * r.arr[1];
		ret.arr[2] = l * r.arr[2];
		ret.arr[3] = l * r.arr[3];
		return ret;
	}
	
	fv4 operator* (fm4 const& l, fv4 r) {
		fv4 ret;
		ret.x = l.arr[0].x * r.x + l.arr[1].x * r.y + l.arr[2].x * r.z + l.arr[3].x * r.w;
		ret.y = l.arr[0].y * r.x + l.arr[1].y * r.y + l.arr[2].y * r.z + l.arr[3].y * r.w;
		ret.z = l.arr[0].z * r.x + l.arr[1].z * r.y + l.arr[2].z * r.z + l.arr[3].z * r.w;
		ret.w = l.arr[0].w * r.x + l.arr[1].w * r.y + l.arr[2].w * r.z + l.arr[3].w * r.w;
		return ret;
	}
	
	fv4 operator* (fv4 l, fm4 const& r) {
		fv4 ret;
		ret.x = l.x * r.arr[0].x + l.y * r.arr[0].y + l.z * r.arr[0].z + l.w * r.arr[0].w;
		ret.y = l.x * r.arr[1].x + l.y * r.arr[1].y + l.z * r.arr[1].z + l.w * r.arr[1].w;
		ret.z = l.x * r.arr[2].x + l.y * r.arr[2].y + l.z * r.arr[2].z + l.w * r.arr[2].w;
		ret.w = l.x * r.arr[3].x + l.y * r.arr[3].y + l.z * r.arr[3].z + l.w * r.arr[3].w;
		return ret;
	}
	
	fm4 transpose (fm4 const& m) {
		return fm4::rows(m.arr[0], m.arr[1], m.arr[2], m.arr[3]);
	}
	
	#define LETTERIFY \
	f32 a = mat.arr[0][0]; \
	f32 b = mat.arr[0][1]; \
	f32 c = mat.arr[0][2]; \
	f32 d = mat.arr[0][3]; \
	f32 e = mat.arr[1][0]; \
	f32 f = mat.arr[1][1]; \
	f32 g = mat.arr[1][2]; \
	f32 h = mat.arr[1][3]; \
	f32 i = mat.arr[2][0]; \
	f32 j = mat.arr[2][1]; \
	f32 k = mat.arr[2][2]; \
	f32 l = mat.arr[2][3]; \
	f32 m = mat.arr[3][0]; \
	f32 n = mat.arr[3][1]; \
	f32 o = mat.arr[3][2]; \
	f32 p = mat.arr[3][3];
	
	f32 det (fm4 const& mat) {
		// optimized from:  // 40 muls, 28 adds, 0 divs = 68 ops
		// to:              // 40 muls, 28 adds, 0 divs = 68 ops
		LETTERIFY
		
		return +a*(+f*(k*p - l*o) -g*(j*p - l*n) +h*(j*o - k*n))
			   -b*(+e*(k*p - l*o) -g*(i*p - l*m) +h*(i*o - k*m))
			   +c*(+e*(j*p - l*n) -f*(i*p - l*m) +h*(i*n - j*m))
			   -d*(+e*(j*o - k*n) -f*(i*o - k*m) +g*(i*n - j*m));
	}
	
	fm4 inverse (fm4 const& mat) {
		// optimized from:  // 200 muls, 125 adds, 1 divs = 326 ops
		// to:              // 116 muls, 83 adds, 1 divs = 200 ops
		LETTERIFY
		
		f32 fl = f * l;
		f32 ep = e * p;
		f32 ip = i * p;
		f32 el = e * l;
		f32 fm = f * m;
		f32 jo = j * o;
		f32 eo = e * o;
		f32 gm = g * m;
		f32 ek = e * k;
		f32 io = i * o;
		f32 hj = h * j;
		f32 kn = k * n;
		f32 kp = k * p;
		f32 gl = g * l;
		f32 hn = h * n;
		f32 lm = l * m;
		f32 ej = e * j;
		f32 in = i * n;
		f32 jm = j * m;
		f32 lo = l * o;
		f32 hm = h * m;
		f32 gj = g * j;
		f32 fk = f * k;
		f32 gi = g * i;
		f32 hi = h * i;
		f32 jp = j * p;
		f32 fo = f * o;
		f32 gn = g * n;
		f32 fp = f * p;
		f32 gp = g * p;
		f32 km = k * m;
		f32 fi = f * i;
		f32 en = e * n;
		f32 ho = h * o;
		f32 ln = l * n;
		f32 hk = h * k;
		
		f32 fkgj = fk - gj;
		f32 iplm = ip - lm;
		f32 enfm = en - fm;
		f32 iokm = io - km;
		f32 fphn = fp - hn;
		f32 kplo = kp - lo;
		f32 jokn = jo - kn;
		f32 eogm = eo - gm;
		f32 fogn = fo - gn;
		f32 ejfi = ej - fi;
		f32 injm = in - jm;
		f32 ephm = ep - hm;
		f32 ekgi = ek - gi;
		f32 elhi = el - hi;
		f32 flhj = fl - hj;
		f32 glhk = gl - hk;
		f32 gpho = gp - ho;
		f32 jpln = jp - ln;
		
		f32 det;
		{ // clac determinate
			det = +a*(+f*(kplo) -g*(jpln) +h*(jokn))
				  -b*(+e*(kplo) -g*(iplm) +h*(iokm))
				  +c*(+e*(jpln) -f*(iplm) +h*(injm))
				  -d*(+e*(jokn) -f*(iokm) +g*(injm));
		}
		f32 inv_det = f32(1) / det;
		f32 ninv_det = -inv_det;
		
		// calc cofactor matrix
		
		f32 cofac_00 = +f*(kplo) -g*(jpln) +h*(jokn);
		f32 cofac_01 = +e*(kplo) -g*(iplm) +h*(iokm);
		f32 cofac_02 = +e*(jpln) -f*(iplm) +h*(injm);
		f32 cofac_03 = +e*(jokn) -f*(iokm) +g*(injm);
		f32 cofac_10 = +b*(kplo) -c*(jpln) +d*(jokn);
		f32 cofac_11 = +a*(kplo) -c*(iplm) +d*(iokm);
		f32 cofac_12 = +a*(jpln) -b*(iplm) +d*(injm);
		f32 cofac_13 = +a*(jokn) -b*(iokm) +c*(injm);
		f32 cofac_20 = +b*(gpho) -c*(fphn) +d*(fogn);
		f32 cofac_21 = +a*(gpho) -c*(ephm) +d*(eogm);
		f32 cofac_22 = +a*(fphn) -b*(ephm) +d*(enfm);
		f32 cofac_23 = +a*(fogn) -b*(eogm) +c*(enfm);
		f32 cofac_30 = +b*(glhk) -c*(flhj) +d*(fkgj);
		f32 cofac_31 = +a*(glhk) -c*(elhi) +d*(ekgi);
		f32 cofac_32 = +a*(flhj) -b*(elhi) +d*(ejfi);
		f32 cofac_33 = +a*(fkgj) -b*(ekgi) +c*(ejfi);
		
		fm4 ret;
		
		ret.arr[0][0] = cofac_00 *  inv_det;
		ret.arr[0][1] = cofac_10 * ninv_det;
		ret.arr[0][2] = cofac_20 *  inv_det;
		ret.arr[0][3] = cofac_30 * ninv_det;
		ret.arr[1][0] = cofac_01 * ninv_det;
		ret.arr[1][1] = cofac_11 *  inv_det;
		ret.arr[1][2] = cofac_21 * ninv_det;
		ret.arr[1][3] = cofac_31 *  inv_det;
		ret.arr[2][0] = cofac_02 *  inv_det;
		ret.arr[2][1] = cofac_12 * ninv_det;
		ret.arr[2][2] = cofac_22 *  inv_det;
		ret.arr[2][3] = cofac_32 * ninv_det;
		ret.arr[3][0] = cofac_03 * ninv_det;
		ret.arr[3][1] = cofac_13 *  inv_det;
		ret.arr[3][2] = cofac_23 * ninv_det;
		ret.arr[3][3] = cofac_33 *  inv_det;
		
		return ret;
	}
	
	#undef LETTERIFY
	
} // namespace vector

