// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#pragma once

 #include "types.hpp"
#include "util.hpp"
#include <cmath>

// windows.h defines min and max by default
#undef min
#undef max

// Math constants
#if _MSC_VER && !__INTELRZ_COMPILER && !__clan_
#include <limits>
#define F32_INF							((float)(1e+300 * 1e+300))
#define F64_INF							(1e+300 * 1e+300)
#define F32_QNAN						std::numeric_limits<float>::quiet_NaN()
#define F64_QNAN						std::numeric_limits<double>::quiet_NaN()
#elif __GNUC__ || __clan_
#define F32_INF							(__builtin_inff())
#define F64_INF							(__builtin_inf())
#define F32_QNAN						((float)__builtin_nan("0"))
#define F64_QNAN						(__builtin_nan("0"))
#endif
namespace vector {
	 // Use std math functions for these
	using std::abs;
	using std::sin;
	using std::cos;
	using std::floor;
	using std::ceil;
	using std::pow;
	using std::round;
	
	constexpr f64 INFd			= F64_INF;
	constexpr f32 INF			= F32_INF;
	constexpr f64 QNANd			= F64_QNAN;
	constexpr f32 QNAN			= F32_QNAN;
	constexpr f64 PId			= 3.1415926535897932384626433832795;
	constexpr f32 PI			= 3.1415926535897932384626433832795f;
	constexpr f64 TAUd			= 6.283185307179586476925286766559;
	constexpr f32 TAU			= 6.283185307179586476925286766559f;
	constexpr f64 SQRT_2d		= 1.4142135623730950488016887242097;
	constexpr f32 SQRT_2		= 1.4142135623730950488016887242097f;
	constexpr f64 EULERd		= 2.7182818284590452353602874713527;
	constexpr f32 EULER			= 2.7182818284590452353602874713527f;
	constexpr f64 DEG_TO_RADd	= 0.01745329251994329576923690768489;	// 180/PI
	constexpr f32 DEG_TO_RAD	= 0.01745329251994329576923690768489f;
	constexpr f64 RAD_TO_DEGd	= 57.295779513082320876798154814105;	// PI/180
	constexpr f32 RAD_TO_DEG	= 57.295779513082320876798154814105f;
	
	////// Scalar math ///////
	
	//// f32
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	f32 wrap (f32 x, f32 range);
	// wrap x into [a,b) range
	f32 wrap (f32 x, f32 a, f32 b);
	f32 wrap (f32 x, f32 a, f32 b, s32* quotient);
	
	s32 floori (f32 x);
	s32 ceili (f32 x);
	s32 roundi (f32 x);
	
	f32 min (f32 l, f32 r);
	f32 max (f32 l, f32 r);
	f32 clamp (f32 x, f32 a=0, f32 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	f32 select (bool c, f32 l, f32 r);
	
	// length(scalar) = abs(scalar), for conformity with vectors
	f32 length (f32 x);
	// length_sqr(scalar) = abs(scalar)^2, for conformity with vectors (for vectors this func would save the sqrt)
	f32 length_sqr (f32 x);
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>, can be useful
	f32 normalize (f32 x);
	// normalize(x) for length(x) != 0 else 0
	f32 normalize_or_zero (f32 x);
	
	// linear interpolation t=0 -> a ; t=1 -> b ; t=0.5 -> (a+b)/2
	f32 lerp (f32 a, f32 b, f32 t);
	// linear mapping (reverse linear interpolation), map(70, 0,100) -> 0.7 ; map(0.5, -1,+1) -> 0.75
	f32 map (f32 x, f32 in_a, f32 in_b);
	// linear mapping, lerp(out_a, out_b, map(x, in_a, in_b))
	f32 map (f32 x, f32 in_a, f32 in_b, f32 out_a, f32 out_b);
	
	//// angle stuff
	f32 to_rad (f32 deg);
	// degress "literal", converts degrees to radiants
	f32 deg (f32 deg);
	f32 to_deg (f32 rad);
	
	//// f64
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	f64 wrap (f64 x, f64 range);
	// wrap x into [a,b) range
	f64 wrap (f64 x, f64 a, f64 b);
	f64 wrap (f64 x, f64 a, f64 b, s64* quotient);
	
	s64 floori (f64 x);
	s64 ceili (f64 x);
	s64 roundi (f64 x);
	
	f64 min (f64 l, f64 r);
	f64 max (f64 l, f64 r);
	f64 clamp (f64 x, f64 a=0, f64 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	f64 select (bool c, f64 l, f64 r);
	
	// length(scalar) = abs(scalar), for conformity with vectors
	f64 length (f64 x);
	// length_sqr(scalar) = abs(scalar)^2, for conformity with vectors (for vectors this func would save the sqrt)
	f64 length_sqr (f64 x);
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>, can be useful
	f64 normalize (f64 x);
	// normalize(x) for length(x) != 0 else 0
	f64 normalize_or_zero (f64 x);
	
	// linear interpolation t=0 -> a ; t=1 -> b ; t=0.5 -> (a+b)/2
	f64 lerp (f64 a, f64 b, f64 t);
	// linear mapping (reverse linear interpolation), map(70, 0,100) -> 0.7 ; map(0.5, -1,+1) -> 0.75
	f64 map (f64 x, f64 in_a, f64 in_b);
	// linear mapping, lerp(out_a, out_b, map(x, in_a, in_b))
	f64 map (f64 x, f64 in_a, f64 in_b, f64 out_a, f64 out_b);
	
	//// angle stuff
	f64 to_rad (f64 deg);
	// degress "literal", converts degrees to radiants
	f64 deg (f64 deg);
	f64 to_deg (f64 rad);
	
	//// s32
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	s32 wrap (s32 x, s32 range);
	// wrap x into [a,b) range
	s32 wrap (s32 x, s32 a, s32 b);
	s32 min (s32 l, s32 r);
	s32 max (s32 l, s32 r);
	s32 clamp (s32 x, s32 a=0, s32 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	s32 select (bool c, s32 l, s32 r);
	
	// length(scalar) = abs(scalar), for conformity with vectors
	s32 length (s32 x);
	// length_sqr(scalar) = abs(scalar)^2, for conformity with vectors (for vectors this func would save the sqrt)
	s32 length_sqr (s32 x);
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>, can be useful
	s32 normalize (s32 x);
	// normalize(x) for length(x) != 0 else 0
	s32 normalize_or_zero (s32 x);
	
	f32 to_rad (s32 deg);
	// degress "literal", converts degrees to radiants
	f32 deg (s32 deg);
	f32 to_deg (s32 rad);
	
	//// s64
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	s64 wrap (s64 x, s64 range);
	// wrap x into [a,b) range
	s64 wrap (s64 x, s64 a, s64 b);
	s64 min (s64 l, s64 r);
	s64 max (s64 l, s64 r);
	s64 clamp (s64 x, s64 a=0, s64 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	s64 select (bool c, s64 l, s64 r);
	
	// length(scalar) = abs(scalar), for conformity with vectors
	s64 length (s64 x);
	// length_sqr(scalar) = abs(scalar)^2, for conformity with vectors (for vectors this func would save the sqrt)
	s64 length_sqr (s64 x);
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>, can be useful
	s64 normalize (s64 x);
	// normalize(x) for length(x) != 0 else 0
	s64 normalize_or_zero (s64 x);
	
	f64 to_rad (s64 deg);
	// degress "literal", converts degrees to radiants
	f64 deg (s64 deg);
	f64 to_deg (s64 rad);
	
	//// s8
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	s8 wrap (s8 x, s8 range);
	// wrap x into [a,b) range
	s8 wrap (s8 x, s8 a, s8 b);
	s8 min (s8 l, s8 r);
	s8 max (s8 l, s8 r);
	s8 clamp (s8 x, s8 a=0, s8 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	s8 select (bool c, s8 l, s8 r);
	
	// length(scalar) = abs(scalar), for conformity with vectors
	s8 length (s8 x);
	// length_sqr(scalar) = abs(scalar)^2, for conformity with vectors (for vectors this func would save the sqrt)
	s8 length_sqr (s8 x);
	// normalize(-6.2f) = -1f, normalize(7) = 1, normalize(0) = <div 0>, can be useful
	s8 normalize (s8 x);
	// normalize(x) for length(x) != 0 else 0
	s8 normalize_or_zero (s8 x);
	
	f32 to_rad (s8 deg);
	// degress "literal", converts degrees to radiants
	f32 deg (s8 deg);
	f32 to_deg (s8 rad);
	
	//// u32
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	u32 wrap (u32 x, u32 range);
	// wrap x into [a,b) range
	u32 wrap (u32 x, u32 a, u32 b);
	u32 min (u32 l, u32 r);
	u32 max (u32 l, u32 r);
	u32 clamp (u32 x, u32 a=0, u32 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	u32 select (bool c, u32 l, u32 r);
	
	f32 to_rad (u32 deg);
	// degress "literal", converts degrees to radiants
	f32 deg (u32 deg);
	f32 to_deg (u32 rad);
	
	//// u64
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	u64 wrap (u64 x, u64 range);
	// wrap x into [a,b) range
	u64 wrap (u64 x, u64 a, u64 b);
	u64 min (u64 l, u64 r);
	u64 max (u64 l, u64 r);
	u64 clamp (u64 x, u64 a=0, u64 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	u64 select (bool c, u64 l, u64 r);
	
	f64 to_rad (u64 deg);
	// degress "literal", converts degrees to radiants
	f64 deg (u64 deg);
	f64 to_deg (u64 rad);
	
	//// u8
	
	// wrap x into range [0,range), negative x wrap back to +range unlike c++ % operator, negative range supported
	u8 wrap (u8 x, u8 range);
	// wrap x into [a,b) range
	u8 wrap (u8 x, u8 a, u8 b);
	u8 min (u8 l, u8 r);
	u8 max (u8 l, u8 r);
	u8 clamp (u8 x, u8 a=0, u8 b=1);
	// equivalent to ternary c ? l : r, for conformity with vectors
	u8 select (bool c, u8 l, u8 r);
	
	f32 to_rad (u8 deg);
	// degress "literal", converts degrees to radiants
	f32 deg (u8 deg);
	f32 to_deg (u8 rad);
	
	//// templated math
	
	
	template<typename T>
	T smoothstep (T x) {
		T t = clamp(x);
		return t * t * (T(3) - T(2) * t);
	}
	
	template<typename T>
	T bezier (T a, T b, T c, f32 t) {
		T d = lerp(a, b, t);
		T e = lerp(b, c, t);
		T f = lerp(d, e, t);
		return f;
	}
	
	template<typename T>
	u8 bezier (T a, T b, T c, T d, f32 t) {
		return bezier(
				lerp(a, b, t),
				lerp(b, c, t),
				lerp(c, d, t),
				t
		);
	}
	
	template<typename T>
	u8 bezier (T a, T b, T c, T d, T e, f32 t) {
		return bezier(
				lerp(a, b, t),
				lerp(b, c, t),
				lerp(c, d, t),
				lerp(d, e, t),
				t
		);
	}
	
	template<typename T>
	T bezier (T a, T b, T c, f64 t) {
		T d = lerp(a, b, t);
		T e = lerp(b, c, t);
		T f = lerp(d, e, t);
		return f;
	}
	
	template<typename T>
	u8 bezier (T a, T b, T c, T d, f64 t) {
		return bezier(
				lerp(a, b, t),
				lerp(b, c, t),
				lerp(c, d, t),
				t
		);
	}
	
	template<typename T>
	u8 bezier (T a, T b, T c, T d, T e, f64 t) {
		return bezier(
				lerp(a, b, t),
				lerp(b, c, t),
				lerp(c, d, t),
				lerp(d, e, t),
				t
		);
	}
} // namespace vector

