// kissmath.hpp generated by vector_srcgen.py
#pragma once

#include "types.hpp"
#include <cmath>

using std::sin;
using std::cos;
using std::floor;
using std::ceil;
using std::pow;
using std::round;

// windows.h defines min and max by default
#undef min
#undef max
#define INFd		F64_INF
#define INF			F32_INF
#define QNANd		F64_QNAN
#define QNAN		F32_QNAN
#define PId			3.1415926535897932384626433832795
#define PI			3.1415926535897932384626433832795f
#define TAUd		6.283185307179586476925286766559
#define TAU			6.283185307179586476925286766559f
#define SQRT_2d		1.4142135623730950488016887242097
#define SQRT_2		1.4142135623730950488016887242097f
#define EULERd		2.7182818284590452353602874713527
#define EULER		2.7182818284590452353602874713527f
#define DEG_TO_RADd	0.01745329251994329576923690768489	// 180/PI
#define DEG_TO_RAD	0.01745329251994329576923690768489f
#define RAD_TO_DEGd	57.295779513082320876798154814105	// PI/180
#define RAD_TO_DEG	57.295779513082320876798154814105f

//
// f32 ////////////////////////////////////////////////////////////////
inline f32  mymod (f32 x, f32 range) {
	f32 modded = std::fmod(x, range);
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline f32  mod_range (f32 x, f32 a, f32 b) {
	x -= a;
	f32 range = b -a;
	
	f32 modulo = mymod(x, range);
	
	return modulo + a;
}
inline f32  mod_range (f32 x, f32 a, f32 b, f32* quotient) {
	x -= a;
	f32 range = b -a;
	
	f32 modulo = mymod(x, range);
	*quotient = floor(x / range);
	
	return modulo + a;
}

inline constexpr f32  to_rad (f32 deg) {
	return deg * DEG_TO_RAD;
}
inline constexpr f32  deg (f32 deg) { // degress "literal", converts degrees to radiants
	return deg * DEG_TO_RAD;
}
inline constexpr f32  to_deg (f32 rad) {
	return rad * RAD_TO_DEG;
}

inline s32  floori (f32 x) {
	return (s32)floor(x);
}
inline s32  ceili (f32 x) {
	return (s32)ceil(x);
}
inline s32  roundi (f32 x) {
	return std::lround(x);
}
inline f32  max (f32 l, f32 r) {
	return std::fmax(l,r);
}
inline f32  min (f32 l, f32 r) {
	return std::fmin(l,r);
}
inline f32  clamp (f32 x, f32 l, f32 h) {
	return min(max(x,l), h);
}
inline f32  select (bool c, f32 l, f32 r) {
	return c ? l : r;
}
inline f32  length (f32 x) {
	return std::fabs(x);
}
inline f32  length_sqr (f32 x) {
	f32 len = std::fabs(x);
	return len * len;
}
inline f32  normalize (f32 x) {
	return x / length(x);
}

inline f32  normalize_or_zero (f32 x) {
	f32 len = length(x);
	if (len != 0) {
		x /= len;
	}
	return x;
}

inline constexpr f32  lerp (f32 a, f32 b, f32 t) {
	return a*(f32(1) -t) +b*t;
}

inline constexpr f32  map (f32 x, f32 in_a, f32 in_b) {
	return (x -in_a)/(in_b -in_a);
}
inline constexpr f32  map (f32 x, f32 in_a, f32 in_b, f32 out_a, f32 out_b) {
	return lerp(out_a, out_b, map(x, in_a, in_b));
}

inline f32  smoothstep (f32 x) {
	f32 t = clamp(x, f32(0), f32(1));
	return t * t * (f32(3) - f32(2) * t);
}

f32  bezier (f32 a, f32 b, f32 c, f32 t);
f32  bezier (f32 a, f32 b, f32 c, f32 d, f32 t);
f32  bezier (f32 a, f32 b, f32 c, f32 d, f32 e, f32 t);
//
// f64 ////////////////////////////////////////////////////////////////
inline f64  mymod (f64 x, f64 range) {
	f64 modded = std::fmod(x, range);
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline f64  mod_range (f64 x, f64 a, f64 b) {
	x -= a;
	f64 range = b -a;
	
	f64 modulo = mymod(x, range);
	
	return modulo + a;
}
inline f64  mod_range (f64 x, f64 a, f64 b, f64* quotient) {
	x -= a;
	f64 range = b -a;
	
	f64 modulo = mymod(x, range);
	*quotient = floor(x / range);
	
	return modulo + a;
}

inline constexpr f64  to_rad (f64 deg) {
	return deg * DEG_TO_RADd;
}
inline constexpr f64  deg (f64 deg) { // degress "literal", converts degrees to radiants
	return deg * DEG_TO_RADd;
}
inline constexpr f64  to_deg (f64 rad) {
	return rad * RAD_TO_DEGd;
}

inline s64  floori (f64 x) {
	return (s64)floor(x);
}
inline s64  ceili (f64 x) {
	return (s64)ceil(x);
}
inline s64  roundi (f64 x) {
	return std::llround(x);
}
inline f64  max (f64 l, f64 r) {
	return std::fmax(l,r);
}
inline f64  min (f64 l, f64 r) {
	return std::fmin(l,r);
}
inline f64  clamp (f64 x, f64 l, f64 h) {
	return min(max(x,l), h);
}
inline f64  select (bool c, f64 l, f64 r) {
	return c ? l : r;
}
inline f64  length (f64 x) {
	return std::fabs(x);
}
inline f64  length_sqr (f64 x) {
	f64 len = std::fabs(x);
	return len * len;
}
inline f64  normalize (f64 x) {
	return x / length(x);
}

inline f64  normalize_or_zero (f64 x) {
	f64 len = length(x);
	if (len != 0) {
		x /= len;
	}
	return x;
}

inline constexpr f64  lerp (f64 a, f64 b, f64 t) {
	return a*(f64(1) -t) +b*t;
}

inline constexpr f64  map (f64 x, f64 in_a, f64 in_b) {
	return (x -in_a)/(in_b -in_a);
}
inline constexpr f64  map (f64 x, f64 in_a, f64 in_b, f64 out_a, f64 out_b) {
	return lerp(out_a, out_b, map(x, in_a, in_b));
}

inline f64  smoothstep (f64 x) {
	f64 t = clamp(x, f64(0), f64(1));
	return t * t * (f64(3) - f64(2) * t);
}

f64  bezier (f64 a, f64 b, f64 c, f64 t);
f64  bezier (f64 a, f64 b, f64 c, f64 d, f64 t);
f64  bezier (f64 a, f64 b, f64 c, f64 d, f64 e, f64 t);
//
// s8 ////////////////////////////////////////////////////////////////
inline s8  mymod (s8 x, s8 range) {
	s8 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline s8  max (s8 l, s8 r) {
	return l >= r ? l : r;
}
inline s8  min (s8 l, s8 r) {
	return l <= r ? l : r;
}
inline s8  clamp (s8 x, s8 l, s8 h) {
	return min(max(x,l), h);
}
inline s8  select (bool c, s8 l, s8 r) {
	return c ? l : r;
}
inline s8  length (s8 x) {
	return std::abs(x);
}
inline s8  length_sqr (s8 x) {
	s8 len = std::abs(x);
	return len * len;
}
inline s8  normalize (s8 x) {
	return x / length(x);
}

//
// s32 ////////////////////////////////////////////////////////////////
inline s32  mymod (s32 x, s32 range) {
	s32 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline s32  max (s32 l, s32 r) {
	return l >= r ? l : r;
}
inline s32  min (s32 l, s32 r) {
	return l <= r ? l : r;
}
inline s32  clamp (s32 x, s32 l, s32 h) {
	return min(max(x,l), h);
}
inline s32  select (bool c, s32 l, s32 r) {
	return c ? l : r;
}
inline s32  length (s32 x) {
	return std::abs(x);
}
inline s32  length_sqr (s32 x) {
	s32 len = std::abs(x);
	return len * len;
}
inline s32  normalize (s32 x) {
	return x / length(x);
}

//
// s64 ////////////////////////////////////////////////////////////////
inline s64  mymod (s64 x, s64 range) {
	s64 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline s64  max (s64 l, s64 r) {
	return l >= r ? l : r;
}
inline s64  min (s64 l, s64 r) {
	return l <= r ? l : r;
}
inline s64  clamp (s64 x, s64 l, s64 h) {
	return min(max(x,l), h);
}
inline s64  select (bool c, s64 l, s64 r) {
	return c ? l : r;
}
inline s64  length (s64 x) {
	return std::abs(x);
}
inline s64  length_sqr (s64 x) {
	s64 len = std::abs(x);
	return len * len;
}
inline s64  normalize (s64 x) {
	return x / length(x);
}

//
// u8 ////////////////////////////////////////////////////////////////
inline u8  mymod (u8 x, u8 range) {
	u8 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline u8  max (u8 l, u8 r) {
	return l >= r ? l : r;
}
inline u8  min (u8 l, u8 r) {
	return l <= r ? l : r;
}
inline u8  clamp (u8 x, u8 l, u8 h) {
	return min(max(x,l), h);
}
inline u8  select (bool c, u8 l, u8 r) {
	return c ? l : r;
}
//
// u32 ////////////////////////////////////////////////////////////////
inline u32  mymod (u32 x, u32 range) {
	u32 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline u32  max (u32 l, u32 r) {
	return l >= r ? l : r;
}
inline u32  min (u32 l, u32 r) {
	return l <= r ? l : r;
}
inline u32  clamp (u32 x, u32 l, u32 h) {
	return min(max(x,l), h);
}
inline u32  select (bool c, u32 l, u32 r) {
	return c ? l : r;
}
//
// u64 ////////////////////////////////////////////////////////////////
inline u64  mymod (u64 x, u64 range) {
	u64 modded = x % range;
	if (range > 0) {
		if (modded < 0) modded += range;
	} else {
		if (modded > 0) modded -= range;
	}
	return modded;
}

inline u64  max (u64 l, u64 r) {
	return l >= r ? l : r;
}
inline u64  min (u64 l, u64 r) {
	return l <= r ? l : r;
}
inline u64  clamp (u64 x, u64 l, u64 h) {
	return min(max(x,l), h);
}
inline u64  select (bool c, u64 l, u64 r) {
	return c ? l : r;
}
