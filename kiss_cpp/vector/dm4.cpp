// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#include "dm4.hpp"

#include "dm2.hpp"
#include "dm3.hpp"
#include "dm2x3.hpp"
#include "dm3x4.hpp"
#include "fm4.hpp"

namespace vector {
	
	//// Accessors
	
	
	// get cell with r,c indecies (r=row, c=column)
	f64 const& dm4::get (int r, int c) const {
		return arr[c][r];
	}
	
	// get matrix column
	dv4 const& dm4::get_column (int indx) const {
		return arr[indx];
	}
	
	// get matrix row
	dv4 dm4::get_row (int indx) const {
		return dv4(arr[0][indx], arr[1][indx], arr[2][indx], arr[3][indx]);
	}
	
	//// Constructors
	
	
	dm4::dm4 () {
		
	}
	
	// supply one value for all cells
	dm4::dm4 (f64 all): 
	arr{
		dv4(all, all, all, all),
		dv4(all, all, all, all),
		dv4(all, all, all, all),
		dv4(all, all, all, all)} {
		
	}
	
	// supply all cells, in row major order for readability -> c<r><c> (r=row, c=column)
	dm4::dm4 (
			f64 c00, f64 c01, f64 c02, f64 c03,
			f64 c10, f64 c11, f64 c12, f64 c13,
			f64 c20, f64 c21, f64 c22, f64 c23,
			f64 c30, f64 c31, f64 c32, f64 c33): 
	arr{
		dv4(c00, c10, c20, c30),
		dv4(c01, c11, c21, c31),
		dv4(c02, c12, c22, c32),
		dv4(c03, c13, c23, c33)} {
		
	}
	
	// static rows() and columns() methods are preferred over constructors, to avoid confusion if column or row vectors are supplied to the constructor
	
	// supply all row vectors
	dm4 dm4::rows (dv4 row0, dv4 row1, dv4 row2, dv4 row3) {
		return dm4(
				row0[0], row0[1], row0[2], row0[3],
				row1[0], row1[1], row1[2], row1[3],
				row2[0], row2[1], row2[2], row2[3],
				row3[0], row3[1], row3[2], row3[3]);
	}
	
	// supply all cells in row major order
	dm4 dm4::rows (
			f64 c00, f64 c01, f64 c02, f64 c03,
			f64 c10, f64 c11, f64 c12, f64 c13,
			f64 c20, f64 c21, f64 c22, f64 c23,
			f64 c30, f64 c31, f64 c32, f64 c33) {
		return dm4(
				c00, c01, c02, c03,
				c10, c11, c12, c13,
				c20, c21, c22, c23,
				c30, c31, c32, c33);
	}
	
	// supply all column vectors
	dm4 dm4::columns (dv4 col0, dv4 col1, dv4 col2, dv4 col3) {
		return dm4(
				col0[0], col1[0], col2[0], col3[0],
				col0[1], col1[1], col2[1], col3[1],
				col0[2], col1[2], col2[2], col3[2],
				col0[3], col1[3], col2[3], col3[3]);
	}
	
	// supply all cells in column major order
	dm4 dm4::columns (
			f64 c00, f64 c10, f64 c20, f64 c30,
			f64 c01, f64 c11, f64 c21, f64 c31,
			f64 c02, f64 c12, f64 c22, f64 c32,
			f64 c03, f64 c13, f64 c23, f64 c33) {
		return dm4(
				c00, c01, c02, c03,
				c10, c11, c12, c13,
				c20, c21, c22, c23,
				c30, c31, c32, c33);
	}
	
	
	// identity matrix
	dm4 dm4::identity () {
		return dm4(
				1,0,0,0,
				0,1,0,0,
				0,0,1,0,
				0,0,0,1);
	}
	
	// Casting operators
	
	
	// extend/truncate matrix of other size
	dm4::operator dm2 () const {
		return dm2(
				arr[0][0], arr[1][0],
				arr[0][1], arr[1][1]);
	}
	
	// extend/truncate matrix of other size
	dm4::operator dm3 () const {
		return dm3(
				arr[0][0], arr[1][0], arr[2][0],
				arr[0][1], arr[1][1], arr[2][1],
				arr[0][2], arr[1][2], arr[2][2]);
	}
	
	// extend/truncate matrix of other size
	dm4::operator dm2x3 () const {
		return dm2x3(
				arr[0][0], arr[1][0], arr[2][0],
				arr[0][1], arr[1][1], arr[2][1]);
	}
	
	// extend/truncate matrix of other size
	dm4::operator dm3x4 () const {
		return dm3x4(
				arr[0][0], arr[1][0], arr[2][0], arr[3][0],
				arr[0][1], arr[1][1], arr[2][1], arr[3][1],
				arr[0][2], arr[1][2], arr[2][2], arr[3][2]);
	}
	
	// typecast
	dm4::operator fm4 () const {
		return fm4(
				(f32)arr[0][0], (f32)arr[0][1], (f32)arr[0][2], (f32)arr[0][3],
				(f32)arr[1][0], (f32)arr[1][1], (f32)arr[1][2], (f32)arr[1][3],
				(f32)arr[2][0], (f32)arr[2][1], (f32)arr[2][2], (f32)arr[2][3],
				(f32)arr[3][0], (f32)arr[3][1], (f32)arr[3][2], (f32)arr[3][3]);
	}
	
	// Elementwise operators
	
	
	dm4& dm4::operator+= (f64 r) {
		*this = *this + r;
		return *this;
	}
	
	dm4& dm4::operator-= (f64 r) {
		*this = *this - r;
		return *this;
	}
	
	dm4& dm4::operator*= (f64 r) {
		*this = *this * r;
		return *this;
	}
	
	dm4& dm4::operator/= (f64 r) {
		*this = *this / r;
		return *this;
	}
	
	// Matrix multiplication
	
	
	dm4& dm4::operator*= (dm4 const& r) {
		*this = *this * r;
		return *this;
	}
	
	// Elementwise operators
	
	
	dm4 operator+ (dm4 const& m) {
		return dm4(
				+m.arr[0][0], +m.arr[1][0], +m.arr[2][0], +m.arr[3][0],
				+m.arr[0][1], +m.arr[1][1], +m.arr[2][1], +m.arr[3][1],
				+m.arr[0][2], +m.arr[1][2], +m.arr[2][2], +m.arr[3][2],
				+m.arr[0][3], +m.arr[1][3], +m.arr[2][3], +m.arr[3][3]);
	}
	
	dm4 operator- (dm4 const& m) {
		return dm4(
				-m.arr[0][0], -m.arr[1][0], -m.arr[2][0], -m.arr[3][0],
				-m.arr[0][1], -m.arr[1][1], -m.arr[2][1], -m.arr[3][1],
				-m.arr[0][2], -m.arr[1][2], -m.arr[2][2], -m.arr[3][2],
				-m.arr[0][3], -m.arr[1][3], -m.arr[2][3], -m.arr[3][3]);
	}
	
	
	dm4 operator+ (dm4 const& l, dm4 const& r) {
		return dm4(
				l.arr[0][0] + r.arr[0][0], l.arr[1][0] + r.arr[1][0], l.arr[2][0] + r.arr[2][0], l.arr[3][0] + r.arr[3][0],
				l.arr[0][1] + r.arr[0][1], l.arr[1][1] + r.arr[1][1], l.arr[2][1] + r.arr[2][1], l.arr[3][1] + r.arr[3][1],
				l.arr[0][2] + r.arr[0][2], l.arr[1][2] + r.arr[1][2], l.arr[2][2] + r.arr[2][2], l.arr[3][2] + r.arr[3][2],
				l.arr[0][3] + r.arr[0][3], l.arr[1][3] + r.arr[1][3], l.arr[2][3] + r.arr[2][3], l.arr[3][3] + r.arr[3][3]);
	}
	
	dm4 operator+ (dm4 const& l, f64 r) {
		return dm4(
				l.arr[0][0] + r, l.arr[1][0] + r, l.arr[2][0] + r, l.arr[3][0] + r,
				l.arr[0][1] + r, l.arr[1][1] + r, l.arr[2][1] + r, l.arr[3][1] + r,
				l.arr[0][2] + r, l.arr[1][2] + r, l.arr[2][2] + r, l.arr[3][2] + r,
				l.arr[0][3] + r, l.arr[1][3] + r, l.arr[2][3] + r, l.arr[3][3] + r);
	}
	
	dm4 operator+ (f64 l, dm4 const& r) {
		return dm4(
				l + r.arr[0][0], l + r.arr[1][0], l + r.arr[2][0], l + r.arr[3][0],
				l + r.arr[0][1], l + r.arr[1][1], l + r.arr[2][1], l + r.arr[3][1],
				l + r.arr[0][2], l + r.arr[1][2], l + r.arr[2][2], l + r.arr[3][2],
				l + r.arr[0][3], l + r.arr[1][3], l + r.arr[2][3], l + r.arr[3][3]);
	}
	
	
	dm4 operator- (dm4 const& l, dm4 const& r) {
		return dm4(
				l.arr[0][0] - r.arr[0][0], l.arr[1][0] - r.arr[1][0], l.arr[2][0] - r.arr[2][0], l.arr[3][0] - r.arr[3][0],
				l.arr[0][1] - r.arr[0][1], l.arr[1][1] - r.arr[1][1], l.arr[2][1] - r.arr[2][1], l.arr[3][1] - r.arr[3][1],
				l.arr[0][2] - r.arr[0][2], l.arr[1][2] - r.arr[1][2], l.arr[2][2] - r.arr[2][2], l.arr[3][2] - r.arr[3][2],
				l.arr[0][3] - r.arr[0][3], l.arr[1][3] - r.arr[1][3], l.arr[2][3] - r.arr[2][3], l.arr[3][3] - r.arr[3][3]);
	}
	
	dm4 operator- (dm4 const& l, f64 r) {
		return dm4(
				l.arr[0][0] - r, l.arr[1][0] - r, l.arr[2][0] - r, l.arr[3][0] - r,
				l.arr[0][1] - r, l.arr[1][1] - r, l.arr[2][1] - r, l.arr[3][1] - r,
				l.arr[0][2] - r, l.arr[1][2] - r, l.arr[2][2] - r, l.arr[3][2] - r,
				l.arr[0][3] - r, l.arr[1][3] - r, l.arr[2][3] - r, l.arr[3][3] - r);
	}
	
	dm4 operator- (f64 l, dm4 const& r) {
		return dm4(
				l - r.arr[0][0], l - r.arr[1][0], l - r.arr[2][0], l - r.arr[3][0],
				l - r.arr[0][1], l - r.arr[1][1], l - r.arr[2][1], l - r.arr[3][1],
				l - r.arr[0][2], l - r.arr[1][2], l - r.arr[2][2], l - r.arr[3][2],
				l - r.arr[0][3], l - r.arr[1][3], l - r.arr[2][3], l - r.arr[3][3]);
	}
	
	
	dm4 mul_elementwise (dm4 const& l, dm4 const& r) {
		return dm4(
				l.arr[0][0] * r.arr[0][0], l.arr[1][0] * r.arr[1][0], l.arr[2][0] * r.arr[2][0], l.arr[3][0] * r.arr[3][0],
				l.arr[0][1] * r.arr[0][1], l.arr[1][1] * r.arr[1][1], l.arr[2][1] * r.arr[2][1], l.arr[3][1] * r.arr[3][1],
				l.arr[0][2] * r.arr[0][2], l.arr[1][2] * r.arr[1][2], l.arr[2][2] * r.arr[2][2], l.arr[3][2] * r.arr[3][2],
				l.arr[0][3] * r.arr[0][3], l.arr[1][3] * r.arr[1][3], l.arr[2][3] * r.arr[2][3], l.arr[3][3] * r.arr[3][3]);
	}
	
	dm4 operator* (dm4 const& l, f64 r) {
		return dm4(
				l.arr[0][0] * r, l.arr[1][0] * r, l.arr[2][0] * r, l.arr[3][0] * r,
				l.arr[0][1] * r, l.arr[1][1] * r, l.arr[2][1] * r, l.arr[3][1] * r,
				l.arr[0][2] * r, l.arr[1][2] * r, l.arr[2][2] * r, l.arr[3][2] * r,
				l.arr[0][3] * r, l.arr[1][3] * r, l.arr[2][3] * r, l.arr[3][3] * r);
	}
	
	dm4 operator* (f64 l, dm4 const& r) {
		return dm4(
				l * r.arr[0][0], l * r.arr[1][0], l * r.arr[2][0], l * r.arr[3][0],
				l * r.arr[0][1], l * r.arr[1][1], l * r.arr[2][1], l * r.arr[3][1],
				l * r.arr[0][2], l * r.arr[1][2], l * r.arr[2][2], l * r.arr[3][2],
				l * r.arr[0][3], l * r.arr[1][3], l * r.arr[2][3], l * r.arr[3][3]);
	}
	
	
	dm4 div_elementwise (dm4 const& l, dm4 const& r) {
		return dm4(
				l.arr[0][0] / r.arr[0][0], l.arr[1][0] / r.arr[1][0], l.arr[2][0] / r.arr[2][0], l.arr[3][0] / r.arr[3][0],
				l.arr[0][1] / r.arr[0][1], l.arr[1][1] / r.arr[1][1], l.arr[2][1] / r.arr[2][1], l.arr[3][1] / r.arr[3][1],
				l.arr[0][2] / r.arr[0][2], l.arr[1][2] / r.arr[1][2], l.arr[2][2] / r.arr[2][2], l.arr[3][2] / r.arr[3][2],
				l.arr[0][3] / r.arr[0][3], l.arr[1][3] / r.arr[1][3], l.arr[2][3] / r.arr[2][3], l.arr[3][3] / r.arr[3][3]);
	}
	
	dm4 operator/ (dm4 const& l, f64 r) {
		return dm4(
				l.arr[0][0] / r, l.arr[1][0] / r, l.arr[2][0] / r, l.arr[3][0] / r,
				l.arr[0][1] / r, l.arr[1][1] / r, l.arr[2][1] / r, l.arr[3][1] / r,
				l.arr[0][2] / r, l.arr[1][2] / r, l.arr[2][2] / r, l.arr[3][2] / r,
				l.arr[0][3] / r, l.arr[1][3] / r, l.arr[2][3] / r, l.arr[3][3] / r);
	}
	
	dm4 operator/ (f64 l, dm4 const& r) {
		return dm4(
				l / r.arr[0][0], l / r.arr[1][0], l / r.arr[2][0], l / r.arr[3][0],
				l / r.arr[0][1], l / r.arr[1][1], l / r.arr[2][1], l / r.arr[3][1],
				l / r.arr[0][2], l / r.arr[1][2], l / r.arr[2][2], l / r.arr[3][2],
				l / r.arr[0][3], l / r.arr[1][3], l / r.arr[2][3], l / r.arr[3][3]);
	}
	
	// Matrix ops
	
	
	dm4 operator* (dm4 const& l, dm4 const& r) {
		dm4 ret;
		ret.arr[0] = l * r.arr[0];
		ret.arr[1] = l * r.arr[1];
		ret.arr[2] = l * r.arr[2];
		ret.arr[3] = l * r.arr[3];
		return ret;
	}
	
	dv4 operator* (dm4 const& l, dv4 r) {
		dv4 ret;
		ret.x = l.arr[0].x * r.x + l.arr[1].x * r.y + l.arr[2].x * r.z + l.arr[3].x * r.w;
		ret.y = l.arr[0].y * r.x + l.arr[1].y * r.y + l.arr[2].y * r.z + l.arr[3].y * r.w;
		ret.z = l.arr[0].z * r.x + l.arr[1].z * r.y + l.arr[2].z * r.z + l.arr[3].z * r.w;
		ret.w = l.arr[0].w * r.x + l.arr[1].w * r.y + l.arr[2].w * r.z + l.arr[3].w * r.w;
		return ret;
	}
	
	dv4 operator* (dv4 l, dm4 const& r) {
		dv4 ret;
		ret.x = l.x * r.arr[0].x + l.y * r.arr[0].y + l.z * r.arr[0].z + l.w * r.arr[0].w;
		ret.y = l.x * r.arr[1].x + l.y * r.arr[1].y + l.z * r.arr[1].z + l.w * r.arr[1].w;
		ret.z = l.x * r.arr[2].x + l.y * r.arr[2].y + l.z * r.arr[2].z + l.w * r.arr[2].w;
		ret.w = l.x * r.arr[3].x + l.y * r.arr[3].y + l.z * r.arr[3].z + l.w * r.arr[3].w;
		return ret;
	}
	
	dm4 transpose (dm4 m) {
		return dm4::rows(m.arr[0], m.arr[1], m.arr[2], m.arr[3]);
	}
	
	
	f64 det (dm4 m) {
		// optimized from:  // 40 muls, 28 adds, 0 divs = 68 ops
		// to:              // 28 muls, 28 adds, 0 divs = 56 ops
		f64 a = m.arr[0][0];
		f64 b = m.arr[0][1];
		f64 c = m.arr[0][2];
		f64 d = m.arr[0][3];
		f64 e = m.arr[1][0];
		f64 f = m.arr[1][1];
		f64 g = m.arr[1][2];
		f64 h = m.arr[1][3];
		f64 i = m.arr[2][0];
		f64 j = m.arr[2][1];
		f64 k = m.arr[2][2];
		f64 l = m.arr[2][3];
		f64 m = m.arr[3][0];
		f64 n = m.arr[3][1];
		f64 o = m.arr[3][2];
		f64 p = m.arr[3][3];
		
		f64 lm = l*m;
		f64 in = i*n;
		f64 ln = l*n;
		f64 jo = j*o;
		f64 km = k*m;
		f64 lo = l*o;
		f64 kn = k*n;
		f64 io = i*o;
		f64 ip = i*p;
		f64 jm = j*m;
		f64 kp = k*p;
		f64 jp = j*p;
		
		// 3D minors
		    // 2D minors
		    f64 det_f = kp - lo;
		    f64 det_g = jp - ln;
		    f64 det_h = jo - kn;
		
		f64 det_a = +f*det_f -g*det_g +h*det_h;
		
		    // 2D minors
		    f64 det_e = kp - lo;
		    f64 det_g = ip - lm;
		    f64 det_h = io - km;
		
		f64 det_b = +e*det_e -g*det_g +h*det_h;
		
		    // 2D minors
		    f64 det_e = jp - ln;
		    f64 det_f = ip - lm;
		    f64 det_h = in - jm;
		
		f64 det_c = +e*det_e -f*det_f +h*det_h;
		
		    // 2D minors
		    f64 det_e = jo - kn;
		    f64 det_f = io - km;
		    f64 det_g = in - jm;
		
		f64 det_d = +e*det_e -f*det_f +g*det_g;
		
		
		return +a*det_a -b*det_b +c*det_c -d*det_d;
	}
} // namespace vector

