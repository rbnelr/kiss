// generated by C:\Users\Me\Desktop\kiss\vector_srcgen\srcgen.py
#pragma once

#include "kissmath.hpp"

//// forward declarations
union dv3;
union dv4;
union bv2;
union iv2;
union s64v2;
union u8v2;

union dv2 {
	struct {
		f64	x, y;
	};
	f64		arr[2];
	
	f64& operator[] (int i);
	f64 operator[] (int i) const;
	
	dv2 ();
	// sets all components to one value
	constexpr dv2 (f64 all);
	// supply all components
	constexpr dv2 (f64 x, f64 y);
	// truncate vector
	constexpr dv2 (dv3 v);
	// truncate vector
	constexpr dv2 (dv4 v);
	
	dv2 operator+= (dv2 r);
	dv2 operator-= (dv2 r);
	dv2 operator*= (dv2 r);
	dv2 operator/= (dv2 r);
	
	//// Conversion operators
	operator iv2 () const;
	operator s64v2 () const;
	operator u8v2 () const;
};

//// arthmethic ops
constexpr dv2 operator+ (dv2 v);
constexpr dv2 operator- (dv2 v);
constexpr dv2 operator+ (dv2 l, dv2 r);
constexpr dv2 operator- (dv2 l, dv2 r);
constexpr dv2 operator* (dv2 l, dv2 r);
constexpr dv2 operator/ (dv2 l, dv2 r);

//// comparison ops
constexpr bv2 operator< (dv2 l, dv2 r);
constexpr bv2 operator<= (dv2 l, dv2 r);
constexpr bv2 operator> (dv2 l, dv2 r);
constexpr bv2 operator>= (dv2 l, dv2 r);
constexpr bv2 operator== (dv2 l, dv2 r);
constexpr bv2 operator!= (dv2 l, dv2 r);
// vectors are equal, equivalent to all(l == r)
constexpr bool equal (dv2 l, dv2 r);
// componentwise ternary c ? l : r
constexpr dv2 select (dv2 c, dv2 l, dv2 r);

//// misc ops
dv2 abs (dv2 v);
dv2 min (dv2 l, dv2 r);
dv2 max (dv2 l, dv2 r);
dv2 clamp (dv2 x, dv2 a=dv2(0), dv2 b=dv2(1));
// get min component of vector, optionally get component index via min_index
f64 min_component (dv2 v, int* min_index=nullptr);
// get max component of vector, optionally get component index via max_index
f64 max_component (dv2 v, int* max_index=nullptr);

dv2 floor (dv2 v);
dv2 ceil (dv2 v);
dv2 round (dv2 v);
s64v2 floori (dv2 v);
s64v2 ceili (dv2 v);
s64v2 roundi (dv2 v);
dv2 pow (dv2 v, dv2 e);
dv2 wrap (dv2 v, dv2 range);
dv2 wrap (dv2 v, dv2 a, dv2 b);

//// linear algebra ops
// magnitude of vector
f64 length (dv2 v);
// squared magnitude of vector, cheaper than length() because it avoids the sqrt(), some algorithms only need the squared magnitude
f64 length_sqr (dv2 v);
// distance between points, equivalent to length(a - b)
f64 distance (dv2 a, dv2 b);
// normalize vector so that it has length() = 1, undefined for zero vector
dv2 normalize (dv2 v);
// normalize vector so that it has length() = 1, returns zero vector if vector was zero vector
dv2 normalize_or_zero (dv2 v);

// linear interpolation t=0 -> a ; t=1 -> b ; t=0.5 -> (a+b)/2
dv2 lerp (dv2 a, dv2 b, dv2 t);
// linear mapping (reverse linear interpolation), map(70, 0,100) -> 0.7 ; map(0.5, -1,+1) -> 0.75
dv2 map (dv2 x, dv2 in_a, dv2 in_b);
// linear mapping, lerp(out_a, out_b, map(x, in_a, in_b))
dv2 map (dv2 x, dv2 in_a, dv2 in_b, dv2 out_a, dv2 out_b);
dv2 smoothstep (dv2 x);
dv2 bezier (dv2 a, dv2 b, dv2 c, f64 t);
dv2 bezier (dv2 a, dv2 b, dv2 c, dv2 d, f64 t);
dv2 bezier (dv2 a, dv2 b, dv2 c, dv2 d, dv2 e, f64 t);

//// angle stuff
constexpr dv2 to_rad (dv2 deg);
// degress "literal", converts degrees to radiants
constexpr dv2 deg (dv2 deg);
constexpr dv2 to_deg (dv2 rad);

