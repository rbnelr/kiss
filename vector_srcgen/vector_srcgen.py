import os
import re
from collections import namedtuple
import itertools

dir = os.path.join('..', 'kiss_cpp', 'vector')

os.makedirs(dir, exist_ok=True)

def fix_indent(text, level):
	text = re.sub(r"^\s*[\n\r]+", "", text) # remove empty leading lines
	text = re.sub(r"[\n\r]*\s*$", "", text) # remove empty trailing lines

	lines = text.splitlines(1)

	base_indent = 0
	
	if lines:
		def get_indent(line, indent_spaces=4):
			
			indent = 0
			for i,c in enumerate(lines[0]):
				if c == ' ':
					indent += 1
				elif c == '\t':
					indent += indent_spaces
				else:
					break # indentation end

			return indent // indent_spaces

		base_indent = get_indent(lines[0])

	return ''.join('\t'*level + l[base_indent:] for l in lines) # remove base indent

class textfile:
	def __init__(self, filename):
		self.filename = filename
		self.text = f'// {filename} generated by {os.path.basename(__file__)}\n'

	def write(self, empty=False):
		filepath = os.path.join(dir, self.filename)

		if not empty:
			with open(filepath, 'w') as f:
				f.write(self.text)
		else:
			try:
				os.remove(filepath)
			except OSError:
				pass

	def add(self, text, nl=0, level=0):
		text = fix_indent(text, level)
		self.text += text + '\n'*(nl + 1)
		
	
floats = ['f32', 'f64']
ints = ['s8', 's32', 's64']
uints = ['u8', 'u32', 'u64']

scalars = floats + ints + uints

f2i_type = {'f32':'s32', 'f64':'s64'}

vec = namedtuple('vec', 'name type size conversions')

vec_sizes = [2,3,4]

vectors = [
	[vec(f'fv{s}', type='f32', size=s, conversions=[f'iv{s}', f'u8v{s}']) for s in vec_sizes],
	[vec(f'dv{s}', type='f64', size=s, conversions=[f'iv{s}', f'u8v{s}']) for s in vec_sizes],
	[vec(f'iv{s}', type='int', size=s, conversions=[f'fv{s}', f'dv{s}']) for s in vec_sizes],
	[vec(f'u8v{s}', type='u8', size=s, conversions=[f'fv{s}', f'dv{s}']) for s in vec_sizes],
]

base_type = { f:f for f in floats }
for tvec in vectors:
	for v in tvec:
		base_type[v.name] = v.type

bool_type = lambda t: 'bool' if (t in floats + ints + uints) else 'b' + t[1:]

def repl_type(text, type):
	text = re.sub(r"\bT\b", type, text)
	text = re.sub(r"\bBT\b", bool_type(type), text)
	return text

class cpp_files:
	def __init__(self, name):
		self.header = textfile(f'{name}.hpp')
		self.source = textfile(f'{name}.cpp')

		self.add_include_guard()
		self.source.add(f'#include "{name}.hpp"', nl=1)

		self.src_empty = True

	def __enter__(self):
		return self
	def __exit__(self, *args):
		self.header.write()
		self.source.write(self.src_empty)

	def add_include_guard(self):
		self.header.add('#pragma once', 1)

	def include(self, name, nl=0):
		self.header.add(f'#include "{name}.hpp"', nl)
	def cppinclude(self, name, nl=0):
		self.header.add(f'#include <{name}>', nl)

	def typedef(self, type, newtype, nl=0):
		self.header.add(f'typedef {type} {newtype};', nl)
		
	def comment(self, text, nl=0):
		self.header.add(f'//\n// {text}', nl)
		self.source.add(f'//\n// {text}', nl)

	def function(self, ret, name, args, text, T, nl=0, level=0, comment=None, inline=True):
		text = fix_indent(text, level=level+1)

		rett = repl_type(ret, T)
		textt = repl_type(text, T)
		argst = ', '.join( repl_type(a, T) for a in args )
		
		rett = f'{rett} ' if rett else ''

		signature = f'{rett} {name} ({argst})'

		declare = f'{signature};'+ (f' // {comment}' if comment else '')
		define = f'{signature} {{'+ (f' // {comment}' if comment else '') +f'\n{textt}\n}}'

		if inline:
			self.header.add('inline '+ define, nl, level)
		else:
			self.header.add(declare, nl, level)
			self.source.add(define, nl, level)

			self.src_empty = False

	def method(self, classname, ret, name, args, text, T, nl=0, level=0, comment=None, inline=True, init_list=None):
		text = fix_indent(text, level=level+1)

		rett = repl_type(ret, T)
		textt = repl_type(text, T)
		argst = ', '.join( repl_type(a, T) for a in args )

		rett = f'{rett} ' if rett else ''
		
		class_declare = f'{rett}{name} ({argst});'+ (f' // {comment}' if comment else '')
		class_define = f'{rett}{name} ({argst})'+ (f': {init_list}' if init_list else '') +' {'+ (f' // {comment}' if comment else '') +f'\n{textt}\n}}'
		
		define = f'{rett}{classname}::{name} ({argst})'+ (f': {init_list}' if init_list else '') +' {'+ (f' // {comment}' if comment else '') +f'\n{textt}\n}}'

		if inline:
			self.header.add('inline '+ class_define, nl, level+1)
		else:
			self.header.add(class_declare, nl, level+1)
			self.source.add(define, nl, level)
			
			self.src_empty = False

float_const = {'f32':'', 'f64':'d'}
mod_func = lambda T, x,y:	f'std::fmod({x}, {y})'	if t in floats else f'{x} % {y}'
abs_func = lambda T:		f'std::fabs(x)'			if T in floats else f'std::abs(x)'
max_func = lambda T:		f'std::fmax(l,r)'		if T in floats else f'l >= r ? l : r'
min_func = lambda T:		f'std::fmin(l,r)'		if T in floats else f'l <= r ? l : r'
round_func = lambda T:		{'f32':'std::lround(x)', 'f64':'std::llround(x)'}[T]

def generic_math(t):
	
	s.function('T', 'mymod', ('T x', 'T range'), """
		T modded = """+ mod_func(t, 'x', 'range') +""";
		if (range > 0) {
			if (modded < 0) modded += range;
		} else {
			if (modded > 0) modded -= range;
		}
		return modded;
	""", T=t, nl=1)
		
	if t in floats:
		s.function('T', 'mod_range', ('T x', 'T a', 'T b'), """
			x -= a;
			T range = b -a;
			
			T modulo = mymod(x, range);
			
			return modulo + a;
		""", T=t)
		
		s.function('T', 'mod_range', ('T x', 'T a', 'T b', 'T* quotient'), """
			x -= a;
			T range = b -a;
			
			T modulo = mymod(x, range);
			*quotient = floor(x / range);
			
			return modulo + a;
		""", T=t, nl=1)
		
	if t in floats:
		s.function('constexpr T', 'to_rad',		('T deg',), f'return deg * DEG_TO_RAD{float_const[t]};', T=t)
		s.function('constexpr T', 'deg',			('T deg',), f'return deg * DEG_TO_RAD{float_const[t]};', T=t, comment='degress "literal", converts degrees to radiants')
		s.function('constexpr T', 'to_deg',		('T rad',), f'return rad * RAD_TO_DEG{float_const[t]};', T=t, nl=1)
			
		s.function(f2i_type[t], 'floori',		('T x',), r'return ('+ f2i_type[t] +')floor(x);', T=t)
		s.function(f2i_type[t], 'ceili',		('T x',), r'return ('+ f2i_type[t] +')ceil(x);', T=t)
		s.function(f2i_type[t], 'roundi',		('T x',), r'return '+ round_func(t) +';', T=t)

	#if t not in uints:
	#	s.function('T', 'abs',	('T x',), f'return '+ abs_func(t,'x') +';', T=t)
	#if t in ints and t != 's64':
	#	s.function('T', 'abs',			('T x',), f'return x >= 0 ? x : -x;', T=t)
			
	s.function('T', 'max',				('T l', 'T r'), f'return '+ max_func(t) +';', T=t)
	s.function('T', 'min',				('T l', 'T r'), f'return '+ min_func(t) +';', T=t)
	s.function('T', 'clamp',			('T x', 'T l', 'T h'), f'return min(max(x,l), h);', T=t)
	s.function('T', 'select',			('BT c', 'T l', 'T r'), r'return c ? l : r;', T=t)
		
	if t not in uints:
		if t in scalars:
			s.function('T', 'length',		('T x',), f'return '+ abs_func(t) +';', T=t)
			s.function('T', 'length_sqr',	('T x',), f'T len = '+ abs_func(t) +';\nreturn len * len;', T=t)

		s.function('T', 'normalize',	('T x',), f'return x / length(x);', T=t, nl=1)
		
	if t in floats:
		s.function('T', 'normalize_or_zero',	('T x',), """
			T len = length(x);
			if (len != 0) {
				x /= len;
			}
			return x;
		""", T=t, nl=1)
		
		s.function('constexpr T', 'lerp',			('T a', 'T b', 'T t'), f'return a*(T(1) -t) +b*t;', T=t, nl=1)
			
		s.function('constexpr T', 'map',			('T x', 'T in_a', 'T in_b'), f'return (x -in_a)/(in_b -in_a);', T=t)
		s.function('constexpr T', 'map',			('T x', 'T in_a', 'T in_b', 'T out_a', 'T out_b'), f'return lerp(out_a, out_b, map(x, in_a, in_b));', T=t, nl=1)
			

		s.function('T', 'smoothstep',	('T x',), """
			T t = clamp(x, T(0), T(1));
			return t * t * (T(3) - T(2) * t);
		""", T=t, nl=1)
			
		s.function('T', 'bezier',	('T a', 'T b', 'T c', base_type[t]+' t'), """
			T d = lerp(a, b, t);
			T e = lerp(b, c, t);
			T f = lerp(d, e, t);
			return f;
		""", T=t, inline=False)
		s.function('T', 'bezier',	('T a', 'T b', 'T c', 'T d', base_type[t]+' t'), """
			return bezier(	lerp(a, b, t),
							lerp(b, c, t),
							lerp(c, d, t),
							t);
		""", T=t, inline=False)
		s.function('T', 'bezier',	('T a', 'T b', 'T c', 'T d', 'T e', base_type[t]+' t'), """
			return bezier(	lerp(a, b, t),
							lerp(b, c, t),
							lerp(c, d, t),
							lerp(d, e, t),
							t);
		""", T=t, inline=False)

	
# math for scalars
with cpp_files('kissmath') as s:
	
	s.include('types')
	s.cppinclude('cmath', nl=1)

	s.header.add("""
		using std::sin;
		using std::cos;
		using std::floor;
		using std::ceil;
		using std::pow;
		using std::round;
		
		// windows.h defines min and max by default
		#undef min
		#undef max

		#define INFd		F64_INF
		#define INF			F32_INF

		#define QNANd		F64_QNAN
		#define QNAN		F32_QNAN

		#define PId			3.1415926535897932384626433832795
		#define PI			3.1415926535897932384626433832795f

		#define TAUd		6.283185307179586476925286766559
		#define TAU			6.283185307179586476925286766559f

		#define SQRT_2d		1.4142135623730950488016887242097
		#define SQRT_2		1.4142135623730950488016887242097f

		#define EULERd		2.7182818284590452353602874713527
		#define EULER		2.7182818284590452353602874713527f

		#define DEG_TO_RADd	0.01745329251994329576923690768489	// 180/PI
		#define DEG_TO_RAD	0.01745329251994329576923690768489f

		#define RAD_TO_DEGd	57.295779513082320876798154814105	// PI/180
		#define RAD_TO_DEG	57.295779513082320876798154814105f
	""", nl=1)
	
	
	for t in floats + ints + uints:
		s.comment(t + ' ////////////////////////////////////////////////////////////////')

		generic_math(t)

def gen_vector(name, type, size, conversions):
	dims = ('x', 'y', 'z', 'w')
	dims = dims[:size]

	def compound_binary(s, op, nl=0):
		if False: # compact
			tmp = ', '.join(f'{d} {op} r.{d}' for d in dims)
			text = f'return *this = {name}({tmp});'
		else:
			text = ''.join(f'{d} {op}= r.{d};\n' for d in dims) + 'return *this;'

		s.method(name, name, f'operator{op}=', (f'{name} r',), text, T=type, nl=nl)

	def conversion(s, to_type, nl=0):
		t = base_type[to_type]

		tmp = ', '.join(f'({t}){d}' for d in dims)
		text = f'return {to_type}({tmp});'
		
		s.method(name, '', f'operator {to_type}', (), text, T=type, nl=nl, inline=False)

	with cpp_files(name) as s:

		s.include('kissmath', nl=1)

		s.header.add('// forward declarations for conversion operators')
		s.header.add('\n'.join(f'union {n};' for n in conversions), nl=1)
		
		s.source.add('\n'.join(f'#include "{n}.hpp";' for n in conversions), nl=1)

		s.header.add(f'''
			union {name} {{
				struct {{
					{type}	{', '.join(dims)};
				}};
				{type}		arr[{size}];
		''', nl=1)
		
		s.method(name, 'T&', 'operator[]', ('int i',), 'return arr[i];', T=type, nl=1)
		
		s.method(name, '', name, (), init_list='', text='', T=type, nl=1)
		s.method(name, 'constexpr', name, ('T all',), init_list=', '.join(f'{d}{{all}}' for d in dims), text='', T=type, nl=1)
		s.method(name, 'constexpr', name, [f'T {d}' for d in dims], init_list=', '.join(f'{d}{{{d}}}' for d in dims), text='', T=type, nl=1)

		if type != 'bool':
			compound_binary(s, '+')
			compound_binary(s, '-')
			compound_binary(s, '*')
			compound_binary(s, '/', nl=1)
			
			for to_vec in conversions:
				conversion(s, to_vec)

		s.header.add('};', nl=1)

for tvec in vectors:
	for v in tvec:
		gen_vector(*v)

#gen_matrix('float', (2,2), 'm2')
#gen_matrix('float', (3,3), 'm3')
#gen_matrix('float', (4,4), 'm4')
#
#gen_quaternion('float', 'fquat')
#
#gen_color('rgb', 'lrgb')
#gen_color('rgba', 'lrgba')


# main file to include
with cpp_files('vector') as s:

	s.include('kissmath', nl=1)

	#
	#s.include('bv2')
	#s.include('bv3')
	#s.include('bv4', nl=1)
	#
	#s.include('fv2')
	#s.include('fv3')
	#s.include('fv4', nl=1)
	#
	#s.include('iv2')
	#s.include('iv3')
	#s.include('iv4', nl=1)
	#
	#s.include('m2')
	#s.include('m3')
	#s.include('m4', nl=1)
	#
	#s.include('fquat', nl=1)
	#
	#s.include('lrgb')
	#s.include('lrgba', nl=2)

	#
	s.typedef('float', 'flt', nl=1)

	#s.typedef('fv2', 'v2')
	#s.typedef('fv3', 'v3')
	#s.typedef('fv4', 'v4')
	