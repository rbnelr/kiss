import os
import re
from collections import namedtuple
import itertools
import shutil
import warnings

def delete_dir_contents(dir, del_subdirs=True):
	import os, shutil

	for the_file in os.listdir(dir):
		file_path = os.path.join(dir, the_file)
		try:
			if os.path.isfile(file_path):
				os.unlink(file_path)
			elif del_subdirs and os.path.isdir(file_path):
				shutil.rmtree(file_path)
		except Exception as e:
			print(e)

# set up output dir
dir = os.path.join('..', 'kiss_cpp', 'vector')

os.makedirs(dir, exist_ok=True)

delete_dir_contents(dir)

#
def delete_dir_contents(dir, del_subdirs=True):
	import os, shutil

	for the_file in os.listdir(dir):
		file_path = os.path.join(dir, the_file)
		try:
			if os.path.isfile(file_path):
				os.unlink(file_path)
			elif del_subdirs and os.path.isdir(file_path):
				shutil.rmtree(file_path)
		except Exception as e:
			print(e)

def format_indentation(text):
	lines = text.splitlines(1)

	indenters = ['{', '(', '[']
	dedenters = ['}', ')', ']']

	def set_indent(line, level):
		
		def unindent(line, indent_spaces=4):
			cur = 0
			def curc(): return line[cur] if cur < len(line) else 0

			def eat_tab():
				nonlocal cur

				spaces_eaten = 0
				while curc() == ' ':
					if spaces_eaten == indent_spaces:
						return True
					cur += 1
					spaces_eaten += 1
				
				if curc() == '\t':
					cur += 1
					return True

				return False

			while eat_tab():
				pass

			return line[cur:]

		line = unindent(line)

		lev = level
		if len(line) > 0 and line[0] in dedenters: # '}' should be on line of its corresponding open bracket
			lev = lev -1 if lev > 0 else 0

		return '\t'*lev + line # remove current indent and add desired indent

	def parse_indent_diff(line):
		diff = 0
		for c in line:
			if		c in indenters:	diff += 1
			elif	c in dedenters:	diff -= 1
		return diff

	indent_level = 0

	for i,l in enumerate(lines):
		line_level = indent_level

		indent_level += parse_indent_diff(l)

		lines[i] = set_indent(l, line_level)

	if indent_level != 0:
		warnings.warn('indent_level not 0, wrong brackets?')

	return ''.join(lines)

class Context:
	pass

def execute_as_python(pycode, **kwargs):
	cnxt = Context()
	cnxt.__dict__ = kwargs

	locs = kwargs
	locs['c'] = cnxt

	val = eval(pycode, {}, locs)
	val = str(val)

	return eval_metacode(val, **kwargs)

def eval_metacode(code, **kwargs):
	output = []

	cur = 0

	def curc():  return code[cur] if cur < len(code) else 0
	def nextc(): return code[cur+1] if (cur+1) < len(code) else 0

	while cur < len(code):
		c = code[cur]
		if c == '$' and nextc() == '{':
			cur += 2 # skip '${'

			begin = cur # text after '${'

			level = 1
			while level > 0: # skip inner backetws by counting opening and closing brackets
				if curc() == '{':	level += 1
				elif curc() == '}':	level -= 1

				cur += 1

			end = cur -1 # on '}'

			python_code = code[begin:end] # code in '${}'

			output.append(execute_as_python(python_code, **kwargs))
		else:
			output.append(c)
		cur += 1

	return ''.join(output)

def write_metacode(filename, metacode, **kwargs):
	header = f'''// generated by {__file__}"
	#pragma once\n'''

	header += eval_metacode(metacode, **kwargs, header=True)
		
	header = format_indentation(header)


	source = f'''// generated by {__file__}
	'''

	source += eval_metacode(metacode, **kwargs, header=False)
		
	source = format_indentation(source)


	with open(os.path.join(dir, f'{filename}.hpp'), 'w') as f:
		f.write(header)
	
	with open(os.path.join(dir, f'{filename}.cpp'), 'w') as f:
		f.write(source)